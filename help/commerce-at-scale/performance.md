---
title: AEM Performance Optimization
description: デフォルトのAdobe Experience Manager設定を最適化して、Adobeコマースで高い負荷をサポートします。
source-git-commit: 63f153365398c3ae7dc7e6214b67705c8a4c7686
workflow-type: tm+mt
source-wordcount: '0'
ht-degree: 0%

---


# AEMパフォーマンス最適化

AEM Dispatcher は、高速で動的な環境の実現に役立つリバースプロキシです。 Apache HTTP Server などの静的 HTML サーバーの一部として機能し、可能な限り多くのサイトコンテンツを静的リソースの形式で保存（「キャッシュ」）します。 このアプローチは、AEMページレンダリング機能とAdobeCommerce GraphQL サービスにできるだけアクセスする必要性を最小限に抑えることを目的としています。 ページの多くを静的 HTML、CSS、JS として提供することで、ユーザーにパフォーマンスのメリットを提供し、環境のインフラストラクチャ要件を軽減できます。 ユーザー間で同じように繰り返される可能性が高いページまたはクエリは、キャッシュの対象として考慮する必要があります。

次の節では、CIF/Adobeコマース環境でAEMに対して効果的なキャッシュを有効にするために、技術的な焦点を絞った推奨領域を大まかに示します。

## AEM Dispatcher に基づく TTL

すべてのAEMプロジェクトで、Dispatcher 上で可能な限り多くのサイトをキャッシュすることがベストプラクティスです。 時間ベースのキャッシュの無効化を使用すると、設定された時間制限の間、サーバー側でレンダリングされた CIF ページがキャッシュされます。 設定された時間が経過すると、次のリクエストはAEMパブリッシャーとAdobeCommerce GraphQL からページを再構築し、次回の無効化まで再び Dispatcher キャッシュに保存します。

TTL キャッシュ機能は、ACS AEM Commons パッケージ内の「Dispatcher TTL」コンポーネントを使用し、dispatcher.any 設定ファイルで/enableTTL &quot;1&quot;を設定することで、AEMで設定できます。

有効にした場合、Dispatcher はバックエンドからの応答ヘッダーを評価し、Cache-Control max-age または Expires 日が含まれる場合は、有効期限と同じ変更時刻を持つ補助的な空のファイルがキャッシュファイルの隣に作成されます。 変更時刻以降にキャッシュされたファイルがリクエストされると、バックエンドから自動的に再リクエストされます。 これにより、製品更新遅延 (TTL) がビジネス関係者によって承認され、承認された後で、手動の介入やメンテナンスを必要としない、効果的なキャッシュメカニズムが実現します。

## ブラウザーのキャッシュ

上記の Dispatcher TTL アプローチは、要求を大幅に減らし、パブリッシャーに読み込みますが、変更される可能性が非常に低いアセットもあり、関連するファイルをユーザーのブラウザーにローカルにキャッシュすることで、Dispatcher への要求を減らすことができます。 例えば、サイトテンプレート内のサイトの各ページに表示されるサイトのロゴは、Dispatcher に対して毎回要求する必要はありません。 代わりに、ユーザーのブラウザーキャッシュに保存できます。 各ページの読み込みに必要な帯域幅の削減は、サイトの応答性とページの読み込み時間に大きな影響を与えます。

ブラウザーレベルでのキャッシュは、通常、「Cache-Control:max-age=&quot;応答ヘッダー。 maxage 設定は、「再検証」を試みる前に、またはサイトから再要求する前に、ファイルをキャッシュする秒数をブラウザに示します。 このキャッシュ max-age の概念は、一般に「キャッシュの有効期限」または TTL(「Time to Live」) と呼ばれます。 規模に応じたコマースエクスペリエンスの配信 — Adobe Experience Manager、コマース統合フレームワーク、Adobeコマース 7

クライアントのブラウザーにキャッシュするように設定できるAEM/CIF/Adobeコマースサイトの一部の領域は次のとおりです。

- 画像 (AEMテンプレート自体内、例：サイトのロゴやテンプレートデザインの画像 — カタログ製品の画像は、Fastly を介してAdobeコマースから呼び出されます。これらの画像のキャッシュについては、後で説明します )
- HTML ファイル（まれに変更されるページの場合 — 利用条件ページなど）
- CSS ファイル
- すべてのサイト JavaScript ファイル（CIF JavaScript ファイルを含む）

## Dispatcher の statfilelevel 猶予期間の最適化

デフォルトの Dispatcher 設定では、 /statfilelevel &quot;0&quot;設定が使用されます。これは、1 つの「.stat」ファイルが htdocs ディレクトリ（ドキュメントルートディレクトリ）のルートに配置されることを意味します。 AEM内のページまたはファイルに変更が加えられると、この単一の stat ファイルの変更時刻が変更時刻に更新されます。 時間がリソースの変更時間よりも新しい場合、Dispatcher はすべてのリソースが無効化されていると見なし、無効化されたリソースに対する後続の要求では、パブリッシュインスタンスへの呼び出しがトリガーされます。 したがって、基本的に、この設定を使用すると、すべてのアクティベーションによってキャッシュ全体が無効になります。

どのサイト（特に負荷の大きいコマースサイト）でも、1 回のページ更新でのみサイト構造全体が無効化されるために、AEM パブリッシュ層に不要な負荷がかかります。

その代わりに、ドキュメントルートディレクトリの htdocs ディレクトリ内のサブディレクトリの深さに対応する statfilelevel の設定を高い値に変更して、特定のレベルにあるファイルが無効化された場合、その.stat ディレクトリレベル以下のファイルのみが更新されるようにします。

例：次の場所に製品ページテンプレートがあるとします。

```
content/ecommerce/us/en/products/product-page.html
```

各フォルダーレベルは、上の表に示すように、「stat level」を持ちます。

| content (docroot) | e コマース | us | en | products | product-page.tml |
|-------------------|-----------|----|----|----------|------------------|
| 0 | 1 | 2 | 3 | 4 | - |

この場合、statfilelevel プロパティをデフォルトの「0」に設定したままにし、product-page.html テンプレートが更新され、無効化のトリガーが有効化されると、docroot からレベル 4 までのすべての.stat ファイルが touch され、無効化され、サイト全体（他の Web サイト、国、言語を含む）のすべてのページで要求がおこなわれます。

ただし、statfilelevel プロパティがレベル 4 に設定され、product-page.html に変更が加えられた場合は、その特定の Web サイト/国/言語の products ディレクトリにある.stat ファイルのみが touch されます。

.stat ファイルのレベルを高く設定しすぎると、パフォーマンスに影響が出る可能性があるので、注意してください。 パフォーマンステストの実行中に一括ファイルのアクティベーションを実行すると、統計レベルを調整する必要のある正しいレベルが得られます。

statfile レベルの設定時に最適化をおこなうもう 1 つの Dispatcher 設定は、 gracePeriod 設定です。 これは、自動無効化された古いリソースを、最後のアクティベーションが発生した後もキャッシュから引き続き使用できる秒数を定義します。 自動無効化されたリソースは、任意のアクティベーションによって無効化されます（パスが dispatcher /invalidate セクションに一致する場合、および statfileslevel プロパティで指定されたレベルに一致する場合）。 「 gracePeriod 」設定を 2 秒に設定すると、パブリッシャーがまだ新しいページの作成中でも、複数のリクエストが継続的にパブリッシャーに送信されるシナリオを防ぐことができます。

>[!NOTE]
>
> このトピックに関するさらに詳しい読み方は、GitHub リポジトリの [aem-dispatcher-experiments](https://github.com/adobe/aem-dispatcher-experiments/tree/main/experiments/gracePeriod) を参照してください。

## CIF — コンポーネントを介した GraphQL キャッシュ

AEM内の個々のコンポーネントをキャッシュするように設定できます。つまり、GraphQL のAdobeへの要求
コマースは 1 回呼び出され、その後、設定された制限時間まで後続のリクエストはAEMキャッシュから取得され、Adobeコマースにはそれ以上の読み込みはおこなわれません。 例えば、すべてのページに表示されるカテゴリツリーとファセット検索機能内のオプションに基づくサイトナビゲーションです。これらは、Adobeコマースの構築にリソースを集中的に要求する 2 つの領域ですが、定期的に変更されないので、キャッシュに適しています。 この方法は、例えば、PDP または PLP がパブリッシャーによって再構築されても、ナビゲーションビルドのリソースを集中的に消費する GraphQL 要求がAdobeコマースにヒットせず、AEM CIF の GraphQL キャッシュから取得できます。

次の例は、ナビゲーションコンポーネントをキャッシュするためのものです。サイト内のすべてのページで同じ GraphQL クエリが送信されます。 以下のリクエストは、ナビゲーション構造の過去 100 個のエントリを 10 分間キャッシュします。

```
venia/components/structure/navigation:true:100:600
```

以下の例では、過去 100 のファセット検索オプションを検索ページに 1 時間キャッシュします。

```
com.adobe.cq.commerce.core.search.services.SearchFilterService:true:100:3600
```

すべてのカスタム http ヘッダーと変数を含むリクエストは、キャッシュが「ヒット」され、Adobeコマースへの繰り返し呼び出しがおこなわれないように、完全に一致する必要があります。 設定後は、このキャッシュを手動で無効にする簡単な方法はありません。 したがって、Adobeコマースに新しいカテゴリが追加された場合、上記のキャッシュに設定された有効期限が切れ、GraphQL 要求が更新されるまで、ナビゲーションに表示されません。 検索ファセットについても同じです。 ただし、このキャッシュで実現できるパフォーマンスのメリットを考えると、通常、これは妥協できるものです。

上記のキャッシュオプションは、「GraphQL クライアント」のAEM OSGi 設定コンソールを使用して設定できます
設定ファクトリ」を参照してください。 各キャッシュ設定エントリは、次の形式で指定できます。

```
• NAME:ENABLE:MAXSIZE:TIMEOUT like for example mycache:true:1000:60 where each attribute is defined as:
    › NAME (String): name of the cache
    › ENABLE (true|false): enables or disables that cache entry
    › MAXSIZE (Integer): maximum size of the cache (in number of entries)
    › TIMEOUT (Integer): timeout for each cache entry (in seconds)
```

## ハイブリッドキャッシュ — キャッシュされた Dispatcher ページ内のクライアント側 GraphQL 要求

ページのキャッシュに対するハイブリッドアプローチも可能です。CIF ページに、常に顧客のブラウザーから直接Adobeコマースに最新情報を要求するコンポーネントを含めることができます。 これは、リアルタイム情報を常に最新の状態に保つことが重要な、テンプレート内の特定のページ領域に役立ちます。PDP 内の製品価格。 動的な価格の一致によって価格が頻繁に変化する場合は、その情報を Dispatcher にキャッシュしないように設定でき、価格は、AEM CIF Web コンポーネントを使用した GraphQL API を介して顧客のブラウザーからクライアント側で直接取得できます。

これは、AEMコンポーネントの設定を使用して設定できます。製品リストページの価格情報の場合は、製品リストテンプレートで設定し、ページ設定で製品リストコンポーネントを選択して、「価格の読み込み」オプションをオンにします。 同じアプローチが在庫レベルにも有効です。

上記の方法は、常に最新の情報を必要とするリアルタイムの場合にのみ使用してください。 上記の価格設定の例では、ビジネス関係者と合意して、低トラフィック時に毎日の価格のみを更新し、その後キャッシュフラッシュ操作を実行できます。 これにより、価格情報を表示する各ページを作成する際に、リアルタイムの価格情報リクエストと、その後のAdobeコマースへの余分な負荷を不要にします。

## キャッシュできない GraphQL 要求

ページ内の特定の動的データコンポーネントはキャッシュしないでください。また、Adobeコマースに対しては、買い物かごやチェックアウトページ全体を通じた呼び出しなど、常に GraphQL 呼び出しが必要になります。 この情報はユーザーに固有で、顧客がサイトで行った行動（買い物かごに商品を追加するなど）によって、常に変化しています。

サイトのデザインでユーザーの役割に基づいて異なる応答が提供される場合、GraphQL クエリの結果は、ログインした顧客に対してキャッシュしないでください。 例えば、複数の顧客グループを作成して、異なる製品価格や、各グループに異なる製品カテゴリの表示を設定できます。 このようなキャッシュの結果は、お客様に別の顧客グループの価格が表示されたり、間違ったカテゴリが表示されたりする可能性があります。

## AEM Dispatcher キャッシュでのトラッキングパラメーターの無視

e コマースサイトは、PPC 検索広告やソーシャルメディアキャンペーンを使用して、サイトへのトラフィックを促進できます。

これらのメディアを使用すると、そのプラットフォームからのアウトバウンドリンクにトラッキング ID が追加されます。 例えば、FacebookはFacebookクリック ID(fbclid) を URL に追加し、Google 広告は Google クリック ID(gclid) を追加します。これにより、AEMのフロントエンドへの受信リンクが以下のように表示されます。

```
https://www.adobe.com/?gclid=oirhgj34y43yowiahg9u3t
```

gclid と fbclid は、広告をクリックするたびに変更されます。これは追跡を目的としていますが、AEMのデフォルト設定では、すべてのリクエストが一意のページとして表示され、Dispatcher がスキップされ、パブリッシャーとAdobeコマースに不要な余分な負荷が生じます。

サージイベント中に、AEMパブリッシャーが過負荷になり、応答しなくなる可能性もあります。 ページに対して無視するように設定されている場合は、そのページが初めて要求されたときにそのページがキャッシュされます。 ページに対する後続の要求は、要求内のパラメーターの値に関係なく、キャッシュされたページに提供されます。

>[!NOTE]
>
>`ignoreUrlParams` の設定の重要性に関する詳細は、GitHub リポジトリの [aem-dispatcher-experiments](https://github.com/adobe/aem-dispatcher-experiments/tree/main/experiments/ignoreUrlParams) を参照してください。

したがって、「ignoreUrlParams」のデフォルトでは、すべてのパラメーターを無視するように設定する必要があります。ただし、GETパラメーターを使用する場合は、ページの HTML 構造が変更されます。 例えば、検索語句がGETパラメーターとして URL に含まれている検索ページです。この場合は、 gclid、fbclid および広告チャネルが使用している他のトラッキングパラメーターなどのパラメーターを無視するように ignoreUrlParams を手動で設定します。

## MPM ワーカーの Dispatcher に対する制限

MPM ワーカーの設定は、Apache HTTP サーバーの高度な設定で、Dispatcher の使用可能な CPU と RAM に基づいて最適化を行うために十分なテストが必要です。 ただし、このホワイトペーパーの範囲では、ServerLimit と MaxRequestWorkers を、サーバの使用可能な CPU と RAM がサポートするレベルに増やし、MinSpareThreads と MaxSpareThreads を MaxRequestWorkers に一致するレベルに増やすことをお勧めします。

この設定により、Apache HTTP は「フル準備設定」のままになります。これは、RAM と複数の CPU コアを持つサーバーに対して高パフォーマンスの設定です。 この設定は、要求を処理するための継続的なオープン接続を維持し、Apache HTTP から最適な応答時間を生成し、フラッシュ販売時などの急激なトラフィックの急増に対応して新しいプロセスの生成に遅延をなくします。
