---
title: パフォーマンスの最適化
description: Adobeコマースでの高負荷をサポートするように、デフォルトのAdobe Experience Manager設定を最適化します。
source-git-commit: 1cff7359ddb4caeca6773ff74b92048c89676f12
workflow-type: tm+mt
source-wordcount: '0'
ht-degree: 0%

---


# デフォルト設定から読み込まれるAEMのパフォーマンス最適化

AEM Dispatcherは、高速で動的な環境の配信に役立つリバースプロキシです。 Apache HTTP Serverなどの静的HTMLサーバーの一部として機能し、可能な限り多くのサイトコンテンツを静的リソースの形式で保存（「キャッシュ」）します。 このアプローチは、AEMページレンダリング機能とAdobeCommerce GraphQLサービスにできるだけアクセスする必要性を最小限に抑えることを目的としています。 ページの多くを静的HTML、CSS、JSとして提供することで、ユーザーにパフォーマンスのメリットをもたらし、環境のインフラストラクチャ要件を軽減できます。 ユーザー間で同じように繰り返される可能性が高いページまたはクエリは、キャッシュの対象と考える必要があります。

以下の節では、CIF/Adobeコマース環境でAEMに対して効果的なキャッシュを有効にするために、技術的に推奨される領域を大まかに示します。

## AEM DispatcherでのTTLベースのキャッシュ

すべてのAEMプロジェクトに対して、Dispatcherで可能な限り多くのサイトをキャッシュすることがベストプラクティスです。 時間ベースのキャッシュの無効化を使用すると、設定された時間、サーバー側でレンダリングされたCIFページがキャッシュされます。 設定された時間が経過すると、次のリクエストはAEMパブリッシャーとAdobeCommerce GraphQLからページを再構築し、次回の無効化まで再びDispatcherキャッシュに保存します。

TTLキャッシュ機能は、ACS AEM Commonsパッケージ内の「Dispatcher TTL」コンポーネントを使用して、dispatcher.any設定ファイルで/enableTTL &quot;1&quot;を設定することで、AEMで設定できます。

有効にした場合、Dispatcherはバックエンドからの応答ヘッダーを評価し、Cache-Control max-ageまたはExpires日が含まれる場合は、有効期限と同じ変更時刻を持つ補助的な空のファイルがキャッシュファイルの隣に作成されます。 変更時刻を過ぎてキャッシュされたファイルがリクエストされると、バックエンドから自動的に再リクエストされます。 これにより、ビジネス関係者が製品更新遅延(TTL)を承認し、受け入れた後で、手動の介入やメンテナンスを必要としない、効果的なキャッシュメカニズムが実現します。

## ブラウザーのキャッシュ

上記のDispatcher TTLアプローチは、リクエストを大幅に減らし、パブリッシャーに読み込みますが、変更されにくいアセットがいくつかあり、関連するファイルをユーザーのブラウザーにローカルにキャッシュすることで、Dispatcherに対する要求も減らせます。 例えば、サイトテンプレート内のサイトの各ページに表示されるサイトのロゴは、Dispatcherに対して毎回要求する必要はありません。 代わりに、ユーザーのブラウザーキャッシュに保存できます。 各ページ読み込みの帯域幅要件の削減は、サイトの応答性とページ読み込み時間に大きな影響を与えます。

ブラウザーレベルでのキャッシュは、通常、「Cache-Control:max-age=&quot;応答ヘッダー。 maxage設定は、「再検証」を試みる前、またはサイトから再要求する前に、ファイルをキャッシュする時間（秒）をブラウザに示します。 このキャッシュmax-ageの概念は、一般に「キャッシュの有効期限」またはTTL（「有効期間」）と呼ばれます。 規模に応じたコマースエクスペリエンスの提供 — Adobe Experience Manager、コマース統合フレームワーク、Adobeコマース7

AEM/CIF/Adobeコマースサイトの一部の領域は、クライアントのブラウザーにキャッシュするように設定できます。

- 画像(AEMテンプレート自体内、例：サイトのロゴやテンプレートデザインの画像 — カタログ製品の画像は、Fastlyを介してAdobeコマースから呼び出されます。これらの画像のキャッシュについては、後で説明します)
- HTMLファイル（まれに変更されるページ用 — 利用条件ページなど）
- CSSファイル
- すべてのサイトJavaScriptファイル（CIF JavaScriptファイルを含む）

## Dispatcher statfilelevel anbd grace period optimization

デフォルトのDispatcher設定では、 /statfilelevel &quot;0&quot;設定が使用されます。これは、1つの「.stat」ファイルがhtdocsディレクトリ（ドキュメントルートディレクトリ）のルートに配置されることを意味します。 AEM内のページまたはファイルに対して変更が行われると、この単一のstatファイルの変更時刻が変更時刻に更新されます。 リソースの変更時刻よりも時刻が新しい場合、Dispatcherは、すべてのリソースが無効化されていると見なし、無効化されたリソースに対する後続の要求では、パブリッシュインスタンスへの呼び出しがトリガーされます。 したがって、基本的に、この設定を使用すると、すべてのアクティベーションによってキャッシュ全体が無効になります。

どのサイト（特に負荷の大きいコマースサイト）でも、1回のページ更新でもサイト構造全体が無効化されるために、AEMパブリッシュ層に不要な負荷がかかります。

その代わりに、ドキュメントルートディレクトリのhtdocsディレクトリ内のサブディレクトリの深さに対応するstatfilelevelの設定を高い値に変更し、特定のレベルにあるファイルが無効になったときに、その.statディレクトリレベル以下のファイルのみが更新されるようにします。

例：次の場所に製品ページテンプレートがあるとします。

```
content/ecommerce/us/en/products/product-page.html
```

上の表に示すように、各フォルダーレベルには「stat level」が表示されます。

| content (docroot) | eコマース | us | en | products | product-page.tml |
|-------------------|-----------|----|----|----------|------------------|
| 0 | 1 | 2 | 1 | 4 | - |

この場合、 statfilelevelプロパティをデフォルトの「0」に設定したままにし、product-page.htmlテンプレートが更新され、無効化のトリガーが有効化されると、docrootからレベル4までのすべての.statファイルがtouchされ、無効化され、サイト全体（他のWebサイト、国、言語を含む）の1回の変更からの要求が実行されます。

ただし、 statfilelevelプロパティがレベル4に設定され、 product-page.htmlに変更が加えられた場合は、その特定のwebサイト/国/言語のproductsディレクトリ内の.statファイルのみがtouchされます。

.statファイルのレベルを高すぎるレベルに設定しないでください。20を超えると、パフォーマンスに影響を与える可能性があります。 パフォーマンステストの実行中に一括ファイルアクティベーションを実行すると、統計レベルを調整する必要のある正しいレベルが得られます。

statfileレベルの設定時に最適化をおこなうもう1つのDispatcher設定は、 gracePeriodです。 これは、自動無効化された古いリソースを、最後のアクティベーションが発生した後にキャッシュから引き続き使用できる秒数を定義します。 自動無効化されたリソースは、任意のアクティベーションによって無効化されます（パスがdispatcher /invalidateセクションに一致する場合、およびstatfilelevelプロパティで指定されたレベルに一致する場合）。 「 gracePeriod 」設定を2秒に設定すると、パブリッシャーがまだ新しいページの作成処理中であっても、複数のリクエストが継続的にパブリッシャーに送信されるシナリオを防ぐことができます。

>[!NOTE]
>
> このトピックに関するさらなる詳細な読み方は、GitHubリポジトリの[aem-dispatcher-experiments](https://github.com/adobe/aem-dispatcher-experiments/tree/main/experiments/gracePeriod)で参照できます。

## CIF — コンポーネントを介したGraphQLキャッシュ

AEM内の個々のコンポーネントをキャッシュするように設定できます。つまり、GraphQLのAdobeへの要求
コマースは1回呼び出され、設定された時間制限まで後続のリクエストはAEMキャッシュから取得され、Adobeコマースにそれ以上の読み込みはおこなわれません。 例としては、すべてのページに表示されるカテゴリツリーとファセット検索機能内のオプションに基づくサイトナビゲーションが挙げられます。これらは、Adobeコマースでのリソース集中型クエリを必要とする2つの領域ですが、定期的に変更されないので、キャッシュに適しています。 この方法は、例えば、パブリッシャーがPDPまたはPLPを再構築しても、ナビゲーションビルドのリソースを集中的に消費するGraphQL要求がAdobeコマースにヒットせず、AEM CIFのGraphQLキャッシュから取得できます。

次の例は、ナビゲーションコンポーネントをキャッシュするためのものです。サイトのすべてのページで同じGraphQLクエリが送信されるからです。 以下のリクエストは、ナビゲーション構造に関する過去100個のエントリを10分間キャッシュします。

```
venia/components/structure/navigation:true:100:600
```

以下の例では、過去100個のファセット検索オプションを検索ページに1時間キャッシュします。

```
com.adobe.cq.commerce.core.search.services.SearchFilterService:true:100:3600
```

すべてのカスタムhttpヘッダーと変数を含むリクエストは、キャッシュが「ヒット」され、Adobeコマースへの繰り返し呼び出しがおこなわれないように、完全に一致する必要があります。 このキャッシュを手動で無効にする方法がない場合は、一度設定しておくと、ここで注意する必要があります。 したがって、Adobeコマースで新しいカテゴリが追加された場合、上記のキャッシュに設定された有効期限が切れ、GraphQL要求が更新されるまで、ナビゲーションに表示されなくなります。 検索ファセットも同じです。 ただし、このキャッシュによって実現されるパフォーマンスのメリットを考えると、通常、これは妥協点として許容されます。

上記のキャッシュオプションは、「GraphQLクライアント」のAEM OSGi設定コンソールを使用して設定できます
Configuration Factory」を参照してください。 各キャッシュ設定エントリは、次の形式で指定できます。

```
• NAME:ENABLE:MAXSIZE:TIMEOUT like for example mycache:true:1000:60 where each attribute is defined as:
    › NAME (String): name of the cache
    › ENABLE (true|false): enables or disables that cache entry
    › MAXSIZE (Integer): maximum size of the cache (in number of entries)
    › TIMEOUT (Integer): timeout for each cache entry (in seconds)
```

## ハイブリッドキャッシュ — キャッシュされたDispatcherページ内のクライアント側GraphQL要求

ページのキャッシュに対するハイブリッドアプローチも可能です。CIFページに、常に顧客のブラウザーから直接Adobeコマースの最新情報を要求するコンポーネントを含めることができます。 これは、リアルタイム情報を常に最新に保つことが重要な、テンプレート内のページの特定の領域に役立ちます。PDP内の製品価格。 動的な価格の一致によって価格が頻繁に変化する場合は、その情報をDispatcherにキャッシュしないように設定でき、価格は、AEM CIF Webコンポーネントを使用したGraphQL APIを介して、顧客のブラウザーからクライアント側でAdobeコマースを直接取得できます。

これは、AEMコンポーネントの設定を使用して設定できます。製品リストページの価格情報の場合は、製品リストテンプレートで設定し、ページ設定で製品リストコンポーネントを選択して、「価格の読み込み」オプションをオンにします。 同じアプローチが在庫レベルにも有効です。

上記の方法は、常に最新の情報が必要な場合にのみ使用してください。 上記の価格設定の例では、低トラフィック時に毎日の価格のみを更新し、その後キャッシュフラッシュ操作を実行することにビジネス関係者と合意できます。 これにより、価格情報を表示する各ページを作成する際に、リアルタイムの価格情報リクエストと、その後のAdobeコマースへの追加の負荷が不要になります。

## キャッシュ不可能なGraphQL要求

ページ内の特定の動的データコンポーネントはキャッシュしないでください。また、Adobeコマース（買い物かごやチェックアウトページ全体の呼び出しなど）には常にGraphQL呼び出しが必要です。 この情報はユーザーに固有で、顧客が買い物かごに商品を追加するなど、サイト上での行動によって常に変化します。

サイトのデザインがユーザーの役割に基づいて異なる応答を提供する場合、GraphQLクエリの結果をログインした顧客にキャッシュしないでください。 例えば、複数の顧客グループを作成して、各グループに異なる製品価格や異なる製品カテゴリの表示を設定できます。 このようなキャッシュの結果は、顧客に別の顧客グループの価格が表示されたり、間違ったカテゴリが表示されたりする可能性があります。

## AEM Dispatcherキャッシュのトラッキングパラメーターを無視する

eコマースサイトは、PPC検索広告やソーシャルメディアキャンペーンを使用して、サイトへのトラフィックを促進できます。

これらのメディアを使用すると、そのプラットフォームからのアウトバウンドリンクにトラッキングIDが追加されます。 例えば、FacebookはFacebook Click ID(fbclid)をURLに追加し、Google AdvertsはGoogle Click ID(gclid)を追加します。これにより、AEMのフロントエンドへの受信リンクが次のように表示されます。

```
https://www.adobe.com/?gclid=oirhgj34y43yowiahg9u3t
```

gclidとfbclidは、広告をクリックするすべてのユーザーによって変更されます。これは追跡を目的としていますが、AEMのデフォルト設定では、すべてのリクエストが一意のページとして表示され、Dispatcherがスキップされ、パブリッシャーとAdobeコマースに不要な余分な負荷が生じます。

サージイベント中に、AEMパブリッシャーが過負荷になり応答しなくなる可能性もあります。 ページに対して無視するように設定されたパラメーターは、そのページが初めて要求されたときにキャッシュされます。 リクエスト内のパラメーターの値に関係なく、ページに対する以降のリクエストは、キャッシュされたページに対して提供されます。

>[!NOTE]
>
>`ignoreUrlParams`の設定の重要性に関する詳細は、GitHubリポジトリの[aem-dispatcher-experiments](https://github.com/adobe/aem-dispatcher-experiments/tree/main/experiments/ignoreUrlParams)を参照してください。

したがって、「ignoreUrlParams」では、デフォルトですべてのパラメーターを無視するように設定する必要があります。ただし、GETパラメーターが使用されてページのHTML構造が変更されます。 例えば、検索語句がGETパラメーターとしてURLに含まれている検索ページがあります。この場合、ignoreUrlParamsを手動で設定して、gclid、fbclidおよび広告チャネルが使用している他のトラッキングパラメーターなどのGETを無視し、通常のサイト操作に必要なパラメーターは影響を受けません。

## MPMワーカーのDispatcherに対する制限

MPMワーカーの設定は、Apache HTTPサーバーの高度な設定で、Dispatcherの使用可能なCPUとRAMに基づいて最適化を徹底的にテストする必要があります。 ただし、このホワイトペーパーの範囲では、 ServerLimitとMaxRequestWorkersを、サーバの使用可能なCPUとRAMでサポートするレベルに増やし、 MinSpareThreadsとMaxSpareThreadsをMaxRequestWorkersに一致するレベルに増やすことをお勧めします。

この設定により、Apache HTTPは「フル準備設定」のままになります。これは、大量のRAMと複数のCPUコアを持つサーバー向けの高パフォーマンス設定です。 この設定は、リクエストを処理するための持続的なオープン接続を維持し、Apache HTTPからの最適な応答時間を生成し、フラッシュ販売時などの急激なトラフィックの急増に対応して新しいプロセスの生成に遅延をなくします。
